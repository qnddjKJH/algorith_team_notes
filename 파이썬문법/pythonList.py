# 리스트
# 인덱스는 0부터 출발
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)
print(a[3])

# 뒤에서 출발 할때는 -1 부터
print(a[-1])
print(a[-4])

# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a)

# 연속적인 위치의 원소들을 가져올 때는 슬라이심(Slicing)을 사용
# 대괄호[] 안에 콜론:을 넣어서 시작인덱스와 끝 인덱스를 설정
# 끝인덱스는 실제 인덱스보다 1을 더크게 설정
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# 두 번째 원소부터 네 번째 원소까지
print(a[1:4])

# 리스트 컴프리헨션
# 일반적인 코드에 비해 매우 간결하게 리스트를 초기화 가능

# 2차원 리스트를 초기화 활 때 효과적으로 사용 가능
# N x M 크기의 2차원 리스트를 한번에 초기화 해야 할 때 매우 유용
# 예시 array = [[0] * m for _ in range(n)]

# array = [[0] * m] * n
# 위 코드는 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식

# i in range(10) 0 ~ 9 까지 i에 담을게~
# i+1 for 그 범위를 i+1 해서 범위 끝까지 배열로 초기화
array = [i for i in range(10)]
print(array)

# 0 부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i % 2 == 1]
print(array)

# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트
array = [i * i for i in range(1, 10)]
print(array)

# N X M 크기의 2차원 리스트 초기화
n = 4
m = 3
array = [[0] * m for _ in range(n)]
print(array)

# 문자열
# " ' 둘다 문자열이다.
# " ' ' " , ' " " ' 경우 있음
string = 'Hello World'
print(string)

string = "Don't you know \"Python\"?"
print(string)

# 문자열에 + 을 이용 문자열이 더해져 연결(Concatenate) 된다
# 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러번 더해진다.
# 문자열도 인덱싱과 슬라이싱 이용 가능
# 다만 문자열은 특정 인덱스의 값을 변경할 수 없다 (Immutable)

# *** 튜플 자료형 ***
# 한 번 선언된 값을 변경 불가
# 리스트는 대괄호 사용, 튜플은 소괄호() 사용
# 리스트보다 상대적으로 공간 효율적
tuple = (1, 2, 3, 4, 5, 6, 7)
print(tuple[3])
print(tuple[1:6])

# 어떤 경우에 사용?
# 서로 다른 성질의 데이터를 묶어서 관리 => 최단 경로 알고리즘 (비용, 노드번호)
# 데이터의 나열을 해싱(Hashing)의 키 값으로 사용 
#   => 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용
# 리스트보다 메모리를 효율적으로 사용해야 할 때
