# 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미
# 최소한의 아이디어를 떠올릴 수 있는 능력 필요

# 일반적인 상황에서 그리디 알고리즘은 최적의 해를 '보장할 수 없다'
# 다만 코테에서는 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서,
# 이를 추론할 수 있어야 풀리도록 출제

# 거스름 돈 문제
# 당신은 음식점의 계산을 도와주는 점원입니다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원,
# 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러
# 주어야 할 동전의 최소 개수를 구하세요, 단, 거슬러 줘야할 돈 N은 항상 10의 배수입니다.

# 최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 주면 된다.

# N = 1260
n = 1260
count = 0
array = [500, 100, 50, 10]

for i in array:
    count += (n // i)
    n %= i
print(count)

# 시간 복잡도 화폐의 갯수(K) 만큼 돌기 때문에 O(K)이다

# 1이 될 때까지
# 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행
# 단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택 가능하다.
# 1. N에서 1을 뺍니다.
# 2. N을 K로 나눕니다.
# N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램 작성
# 문제의 핵심은 '과정이 수행되는 최소 횟수'이다.
n, k = map(int, input().split())
result = 0
while True:
    if(n == 1):
        break
    if(n % k == 0):
        n //= k
        result += 1
    else:
        n -= 1
        result += 1
print(result)

# 답안
# 답안은 테크닉이 들어가 있다.
# 위의 내가 한 답처럼 해도 된다
# 밑에는 속도도 잘 나오게 한 답안이다 O(log n) 의 속도를 보여준다
n, k = map(int, input().split())
result = 0
while True:
    target = (n // k) * k # 몫을 구하고 다시 곱해서 '1을 한번에 여러번 뺀' 연산을 보여준다
    # 예) 26 3 일 경우 이 과정에서 24로 26-24 하면 2번 1을 뺀 과정이 나온다
    result += (n - target) # 1을 '여러번' 뺀만큼의 횟수를 더해준다.
    n = target
    if n < k:
        break
    result += 1 # 나누기 연산 1번 더해준다
    n //= k     # 실제로 나누어서 n 을 줄여준다.

result += (n - 1)
print(result)


# 고합기 혹은 더하기
# 각 자리가 숫자 (0 부터 9) 로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩
# 모든 숫자를 확인하며 숫자 사이에 "x" 혹은 "+" 연산자를 넣어 결과적으로 만들어질 수 있는 가장
# 큰 수를 구하는 프로그램 작정
# 단, +보다 x를 먼저 계산하는 일방적인 방식과 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다.
# 예) 02984 가장 큰수 ((((0+2) x 9 ) x 8) x 4) = 576
# 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어진다.

# 0은 곱하면 0이 되고 1인 경우는 더한 값보다 곱한 값이 작으므로 두 가지 경우를 생각하자
# 답안
data = input()
result = int(data[0])
# 문자열 string 타입을 그냥 쪼갤 수 있다. 미쵸...상상을 못했네...
# result = int(data[0]) data 로 들어온 문자열의 첫 글자를 정수형으로 result에 저장한다
# 알고리즘은 생각한것과 유사하여 넘어감
# 파이썬에 익숙하지 않아서 잘 못적었음
for i in range(1, len(data)):
    num = int(data[i])
    if num <= 1 or result <= 1:
        result += num
    else:
        result *= num

print(result)

# 모험가 길드 문제
# N명의 모험가가 있다. 길드는 모험가를 대상으로 '공포도'를 측정 '공포도'가 높은 모험가는
# 쉽게 공포에 빠져 위험 상황에서 제대로 대처할 능력이 떨어진다.
# 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상
# 으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정하였습니다.
# 동빈이는 최대 몇개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을
# 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하시오
# 공포도가 1이면 혼자, 2이면 2명이상, 3이면 3명이상 그룹으로 구성하여 가여야 한다.
number = int(input())
adlist = list(map(int, input().split()))
adlist.sort()

result = 0    # 그룹 수
cnt = 0    # 현재 그룹에 포함된 모험가의 수, 그룹 체크 용도

for i in adlist:
    cnt += 1
    if cnt >= i:    # 모험가의 수와 모험가의 공포도가 일치하거나 수가 많으면 그룹 결성
        result += 1
        cnt = 0

print(result)

